Fast multiset construction

need: occupancy bitvector w/ rank
need: zero-compressed right-unique multiplicity bitvector
	build a block at a time, noting the number of skipped blocks in between

	prev = first(data)
	emitUnique(prev) # just build the bitvector; rank superblocks in a subsequent block pass
	for i in 2:length(data)
		cur = data[i]
		if cur != prev
			emitOne(cur) # select superblock every 32 bits, plus zero-compression
			emitUnique(cur)
		else
			emitZero(cur)
		end
	end

make a BitVectorBuilder and SelectBitVectorBuilder

class BitVectorBuilder {
	initialize(length) {
		const n = Math.ceil(length >> 5);
		this.blocks = new Uint32Array(n);
	}

	one(position) {
		const blockIndex = position >>> 5;
		const bitOffset = position & 31;
		blocks[blockIndex] |= 1 << bitOffset;
	}
}

class SelectBitVectorBuilder {
	initialize(length) {
		const n = Math.ceil(length >> 5);
		this.blocks = new Uint32Array(n);
		// will need to be resized down at the end; don't
		// know the number of ones ahead of time
		this.selectSuperblocks = new Uint32Array(n);
		this.numOnes = 0;
		this.prevBlockIndex = 0;
		this.numZeroBlocks = 0;
	}
	one(position) {
		const blockIndex = position >>> 5 - numZeroBlocks;
		if (blockIndex - this.prevBlockIndex > 1) {
			numNewZeroBlocks = blockIndex - prevBlockIndex - 1;
			numZeroBlocks += numNewZeroBlocks;
			blockIndex -= numNewZeroBlocks;
			// need to mark zero blocks 
		}
		const bitOffset = position & 31;
		if (this.numOnes % 32 === 0) {
			const selectSampleIndex = this.numOnes >>> 5;
			// number of 1 bits in this block before the (32k+1)th bit
			const adjustment = popcount(blocks[blockIndex]);
			this.selectSuperblocks[selectSampleIndex] = (blockIndex << 5) | adjustment;
		}
		blocks[blockIndex] |= 1 << bitOffset;
		this.numOnes += 1;
	}
}

API Design

1d

	index(data)
		build an index to prepare for fast range queries
		returns the sorted bitvector multiset

	query(index, x)
		rank operation on the sorted multiset, ie. binarySearchAfter
		return the number of datapoints less than or equal to the point x

	queryBatch(out, index, xs)
		accept a sorted list of query points xs
		return a sorted list of results
		(naive impl: for loop over query())

	linearQueries(out, index, x1, x2, step)
		query x1 + k * step â‰¤ x2
		return the number of points

2d
	
	index(x, y)
		return 1d index on morton codes

	queryTiles(out, index, x1, y1, x2, y2, tileSize)

	queryTile(index, x, y, tileSize)
